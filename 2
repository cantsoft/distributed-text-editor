use crate::protocol;
use bincode::Result;
use bytes::Bytes;
use futures::StreamExt;

use std::net::{Ipv4Addr, SocketAddr};

use tokio::io::AsyncRead;
use tokio::net::UdpSocket;
use tokio::net::TcpListener;
use tokio::sync::mpsc;
use tokio_util::codec::{FramedRead, LengthDelimitedCodec};
use tokio_util::sync::CancellationToken;

type PacketSender = mpsc::Sender<protocol::IngressPacket>;

async fn stream_reader<R, F>(
    stream: R,
    tx: PacketSender,
    token: CancellationToken,
    packet_constructor: F,
) where
    R: AsyncRead + Unpin,
    F: Fn(Bytes) -> protocol::IngressPacket,
{
    let mut framed = FramedRead::new(stream, LengthDelimitedCodec::new());

    loop {
        tokio::select! {
            _ = token.cancelled() => return,
            maybe_frame = framed.next() => {
                match maybe_frame {
                    Some(Ok(bytes)) => {
                        let packet = packet_constructor(bytes.freeze());
                        if tx.send(packet).await.is_err() {
                            return;
                        }
                    }
                    Some(Err(e)) => {
                        eprintln!("Framing error: {}", e);
                    }
                    None => return,
                }
            }
        }
    }
}

async fn run_tcp_server(
    tx: PacketSender,
    token: CancellationToken,
) -> Result<(), Box<dyn std::error::Error>> {
    let listener = TcpListener::bind("127.0.0.1:1234").await?;
    loop {
        tokio::select! {
            _ = token.cancelled() => return Ok(()),
            accept_result = listener.accept() => {
                match accept_result {
                    Ok((socket, addr)) => {
                        eprintln!("New TCP connection: {}", addr);
                        let tx_inner = tx.clone();
                        let token_inner = token.clone();
                        tokio::spawn(async move {
                            stream_reader(
                                socket,
                                tx_inner,
                                token_inner,
                                protocol::IngressPacket::FromTcp
                            ).await;
                        });
                    }
                    Err(e) => eprintln!("TCP accept error: {}", e),
                }
            }
        }
    }
}

pub async fn run_service() -> Result<(), Box<dyn std::error::Error>> {
    let (tx, rx) = mpsc::channel(32);
    let token = CancellationToken::new();

    let tx_stdin = tx.clone();
    let token_stdin = token.clone();
    tokio::spawn(async move {
        stream_reader(
            tokio::io::stdin(),
            tx_stdin,
            token_stdin,
            protocol::IngressPacket::FromStdin,
        )
        .await;
    });

    let tx_tcp = tx.clone();
    let token_tcp = token.clone();
    tokio::spawn(async move {
        if let Err(e) = run_tcp_server(tx_tcp, token_tcp).await {
            eprintln!("TCP Server crashed: {}", e);
        }
    });

    drop(tx);

    protocol::process_packets(rx, token.clone()).await;

    Ok(())
}

const MULTICAST_ADDR: &str = "239.0.0.1";
const PORT: u16 = 9000;

pub async fn run_multicast(port: u16, ip_address: &str) -> Result<(), Box<dyn std::error::Error>> {
    let multicast_addr: Ipv4Addr = ip_address.parse().unwrap();
    let interface_addr

    Ok(())
}

pub async fn run_multicast_discovery() -> std::io::Result<()> {
    let multi_addr: Ipv4Addr = MULTICAST_ADDR.parse().unwrap();
    let interface_addr = Ipv4Addr::new(0, 0, 0, 0);

    let socket = UdpSocket::bind(format!("0.0.0.0:{}", PORT)).await?;

    socket.join_multicast_v4(multi_addr, interface_addr)?;

    socket.set_multicast_loop_v4(true)?;

    println!("Listening for peers on {}:{}", MULTICAST_ADDR, PORT);

    let mut buf = [0u8; 1024];

    loop {
        let target_addr: SocketAddr = format!("{}:{}", MULTICAST_ADDR, PORT).parse().unwrap();
        socket.send_to(b"HELLO_PEER", target_addr).await?;

        let (len, addr) = socket.recv_from(&mut buf).await?;
        println!("Odebrano od {}: {:?}", addr, &buf[..len]);

        tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;
    }
}